<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS</title>
</head>
<body>
    <script>
        console.log(typeof undefined); //Undefiend
        console.log(typeof null); //object
        /* 둘다 값이 없어서 값만 확인했을 떈 동일하다.
        하지만 null은 의도적으로 값을 비워둔 상태고, undefined는 말 그대로 아무런 타입 선언도 이루어지지 않은 상태다. */
        console.log(null == undefined); //true
        console.log(null === undefined); //false

        /*ES에서 변수는 선언하고, 함수는 정의한다.
        하지만 undefined의 '정의'는 변수가 선언되었지만 변수 값을 할당하지 않은 상태를 말한다.*/
        /* null은 typeof로 자료형을 확인하면 object를 반환한다.
        엄밀히 말하자면 원시 자료형보다는 객체이고 참조 자료형이다. */


        // 전위 연산자: 선 증가 후 연산 ++num 값을 1 증가한 후 나머지 코드 진행
        // 후위 연산자: 선 연산 후 증가 num++ 코드 진행 후 값을 1 증가
        let i = 3;
        while (i--) {
            console.log(`${i}번째 반복했습니다.`);
        } //console 지나고나서 2로 줄어듦
        console.log(i); //2

        let j = 3;
        while (--j) { // 2(선감산)
        console.log(`${j}번째 반복했습니다.`);
        }

        let k = 0;
        while (k<5) {
            console.log(`${k}번째`);
            k++;
        }
        /* 하지만 보통의 경우 증감문이 마지막 실행 순서라서 전위연산자와 후위연산자가 차이 없다. 
        다만 관례상 후위연산자를 쓴다. */
        for(let i=0; i<5; ++i) {
            console.log('증가 연산자를 앞에');
        }
        for(let i=0; i<5; i++) {
            console.log('증가 연산자를 뒤에');
        }

        //객체 만들기
        let favThing = {};
        favThing.color = "yellow";
        favThing.brand = "apple";
        favThing.season = "winter";
        favThing.me = "do my best";
        favThing.song = "don't look back in anger";
        console.log("fav Thing", favThing);
        //'prototype: Object'에서 프로토타입이 뭘까? 직역하면 '원형'인데.'

        let favThing2 = {
        color : "yellow",
        brand : "apple",
        season : "winter",
        me : "do my best",
        song : "don't look back in anger"
        }
        console.log(favThing2);
    </script>
</body>
</html>